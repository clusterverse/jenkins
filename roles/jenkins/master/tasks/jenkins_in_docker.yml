---
## Note: install Jenkins Docker from source (https://github.com/jenkinsci/docker), because the image sets the uid and gid to 1000, which
##  causes irreconcilable conflicts with the host.  See also https://github.com/jenkinsci/docker/issues/112

- name: jenkins Docker build
  block:
#    - name: jenkins Docker | prune old docker images & volumes
#      become: yes
#      shell: "docker image prune -f; docker volume prune -f"

    - name: jenkins Docker | Create the Docker network
      become: yes
      docker_network:
        name: jenkins
        ipam_config: "[{%- if jenkins_master.docker_network.cidr is defined -%}{'subnet': jenkins_master.docker_network.cidr}{%- endif -%}]"
      when: "jenkins_master.docker_network.network_mode=='bridge' and jenkins_master.docker_network.name is defined"

    - name: jenkins Docker | Create temporary build directory
      become: yes
      tempfile:
        state: directory
        suffix: DockerBuildTEMP
      register: tmp_build_dir

    - name: jenkins Docker | get host docker group (stored as getent_group['docker'][1])
      getent:
        database: group
        key: docker

    - name: jenkins Docker | git clone Jenkins docker build repo from github
      become: yes
      git:
        repo: https://github.com/jenkinsci/docker.git
        dest: "{{ tmp_build_dir.path }}"

    - name: jenkins Docker | create JCasC config file
      become: yes
      copy:
        content: "{{ casc_config | to_nice_json }}"       # Note: we cannot use {{ jenkins_master.casc_config | string | from_yaml | to_nice_yaml(indent=2, width=10000) }} because the string filter templates the multi-line vaulted ssh keys as double-escaped newlines (hence the re-templating, as vars, below)
        dest: "{{jenkins_master.casc_file.local}}"
        decrypt: yes
        owner: "{{ jenkins_uid }}"
        group: "{{ jenkins_gid }}"
      vars:
        _casc_config: "{{jenkins_master.casc_config}}"     # Note: We need to re-template {{jenkins_master.casc_config}} so that the vault credentials are templated-out correctly before filtering as json/yaml.
        casc_config: "{{_casc_config | combine({'jenkins': {'numExecutors': ansible_processor_vcpus * jenkins_master.jcasc_numExecutorsMultiplier}}, recursive=True)}}"
      register: r__copy_jcasc

    - name: jenkins Docker | augment the dockerfile
      become: yes
      blockinfile:
        path: "{{ tmp_build_dir.path }}{{jenkins_master.docker.repo_dockerfile_path}}"
        insertbefore: '^ENTRYPOINT'
        block: |
          USER root
          ENV PIPENV_VENV_IN_PROJECT=true
          ENV CASC_JENKINS_CONFIG "{{ jenkins_master.casc_file.remote | dirname }}"

          # Options for jenkins-plugin-cli: https://github.com/jenkinsci/plugin-installation-manager-tool
          RUN mkdir -p ${CASC_JENKINS_CONFIG} && \
          jenkins-plugin-cli --verbose --plugins {{jenkins_master.plugins | join(' ') }}

          ### Note: use pip to install pipenv (not apt) to avoid pypa/pipenv#2196 (when using PIPENV_VENV_IN_PROJECT)
          RUN apt-get update \
          && apt-get install -y git vim sudo python3-pip \
          && apt-get install -y --no-install-recommends apt-transport-https ca-certificates curl gnupg-agent software-properties-common \
          && pip3 install pipenv \
          && curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - \
          && add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable" \
          && apt-get update && apt-get install -y --no-install-recommends docker-ce

          # Change the docker group ID to the same as the host so that non-root users can access the socket via its group membership.
          # Note: Cannot `usermod -a -G docker jenkins` the Jenkins user to the docker group here, because the container is already running as the jenkins user.  Need to start the container with --group-add docker (in Ansible, add to the 'groups')
          RUN groupmod -g {{docker_group_id}} docker
      vars:
        docker_group_id: "{{getent_group['docker'][1]}}"

    - name: jenkins Docker | remove the JENKINS_SHA check
      become: yes
      lineinfile:
        path: "{{ tmp_build_dir.path }}{{jenkins_master.docker.repo_dockerfile_path}}"
        regexp: '.*?JENKINS_SHA.*sha256sum.*'
        line: "&& /bin/true"

    - name: jenkins Docker | Get the Jenkins release maven-metadata
      uri:
        url: "https://repo.jenkins-ci.org/releases/org/jenkins-ci/main/jenkins-war/maven-metadata.xml"
        return_content: yes
        status_code: 200
      register: r__uri

    - name: jenkins Docker | Extract the xml from the Jenkins release metadata
      xml:
        xmlstring : "{{r__uri.content}}"
        content: "text"
        xpath: "/metadata/versioning/versions/version"
      delegate_to: localhost
      run_once: true
      register: r__xml

    - set_fact:
        jenkins_version: "{%-if jenkins_master.docker.version == 'latest-lts' -%}{{_latest_jenkins_version_lts}}{%- elif jenkins_master.docker.version == 'latest' -%}{{_latest_jenkins_version}}{%- else -%}{{jenkins_master.docker.version}}{%- endif -%}"
      vars:
        _latest_jenkins_version: "{{r__xml.matches | json_query(\"[].version\") | semver_sort | last }}"
        _latest_jenkins_version_lts: "{{r__xml.matches | json_query(\"[].version\") | map('regex_search', '^[0-9]+\\.[0-9]+\\.[0-9]+$') | list | json_query(\"[]\") | semver_sort | last }}"

    - name: jenkins Docker | Build the jenkins Docker image
      become: yes
      docker_image:
        source: build
        build:
          dockerfile: "{{ tmp_build_dir.path }}{{jenkins_master.docker.repo_dockerfile_path}}"
          args:
            uid: "{{ jenkins_uid }}"
            gid: "{{ jenkins_gid }}"
            JENKINS_VERSION: "{{ jenkins_version }}"
          network: host
          pull: yes
          nocache: no       # Setting this to 'yes' will cause a rebuild every time, forcing a new image to be built, even if no changes have been made to the Dockerfile.
          rm: yes
          path: "{{ tmp_build_dir.path }}"
        force_source: true
        name: "jenkins_master:{{ jenkins_version }}"
      register: r__docker_image

    - name: jenkins Docker | Get the jenkins Docker image id
      become: yes
      docker_image_info:
        name: "jenkins_master:{{ jenkins_version }}"
      register: r__docker_image_info

    - name: jenkins Docker | Create and run the jenkins Docker container
      become: yes
      docker_container:
        cleanup: no
        detach: yes
        name: "jenkins_master"
        user: "{{jenkins_uid}}:{{jenkins_gid}}"
        groups: ["docker"]
        hostname: "docker--{{inventory_hostname}}"
        image: "{{r__docker_image_info.images[0].Id}}"
        recreate: no        # Setting this to 'yes' forces reprovisioning of the container even if the image has not changed
        state: started
        restart: "{%- if r__copy_jcasc.changed -%}yes{%-else-%}no{%- endif -%}"
        restart_policy: "always"
        network_mode: "{{ jenkins_master.docker_network.network_mode | default('host') }}"
        networks_cli_compatible: yes
        networks: "[{%- if jenkins_master.docker_network.network_mode=='bridge' and jenkins_master.docker_network.name is defined -%}{'name': '{{jenkins_master.docker_network.name}}'}{%- endif -%}]"
        ports: ["80:8080", "443:8443", "50000:50000"]
        env:
          # NOTE: EXCLUDE_SESSION_ID and DISABLE_CSRF_PROTECTION are needed for Jenkins Job Builder, which doesn't currently support either Session IDs or CSRF crumb (https://storyboard.openstack.org/#!/story/2006489)
          JAVA_OPTS: "-Djenkins.install.runSetupWizard=false -Dhudson.security.csrf.DefaultCrumbIssuer.EXCLUDE_SESSION_ID=true -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true -Dpermissive-script-security.enabled=true"
        mounts:
          - target: "{{jenkins_home_dir}}"
            source: "jenkins_home"
            type: volume
          - target: "/var/run/docker.sock"
            source: "/var/run/docker.sock"
            type: bind
          - target: "{{jenkins_master.casc_file.remote}}"
            source: "{{jenkins_master.casc_file.local}}"
            type: bind

    - name: jenkins Docker | Wait for Jenkins API to become available
      uri:
        url: "http://127.0.0.1:80/api"
        status_code: 200
      register: r__uri
      until: r__uri.status == 200
      retries: 60
      delay: 1

    - name: jenkins Docker | truncate JCasC config file (do not delete, as it is bind-mounted, so needs to exist if the VM restarts)
      become: yes
      copy: { content: "", dest: "{{jenkins_master.casc_file.local}}" }

    - name: jenkins Docker | Remove temporary build directory
      become: yes
      file:
        path: "{{ tmp_build_dir.path }}"
        state: absent
